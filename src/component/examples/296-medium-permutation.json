{"code":"/**\r\n * ref:\r\n * - https://github.com/type-challenges/type-challenges/blob/master/questions/296-medium-permutation/README.md\r\n * - https://github.com/type-challenges/type-challenges/issues/614\r\n * - https://github.com/type-challenges/type-challenges/issues/548\r\n */\r\n\r\n/**\r\n * eg.\r\n * \r\n * \r\n    checks([\r\n        check<Permutation<never>, [], Test.Pass>(),\r\n        check<Permutation<'A'>, ['A'], Test.Pass>(),\r\n        check<Permutation<'A' | 'B' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A'], Test.Pass>(),\r\n        check<Permutation<'B' | 'A' | 'C'>, ['A', 'B', 'C'] | ['A', 'C', 'B'] | ['B', 'A', 'C'] | ['B', 'C', 'A'] | ['C', 'A', 'B'] | ['C', 'B', 'A'], Test.Pass>(),\r\n    ])\r\n */\r\n\r\nexport type function Permutation = (Union, UnionCopy = Union) => ^{\r\n    if(IsNever<Union> extends true) {\r\n        return []\r\n    } else if(UnionCopy extends infer Item){\r\n        return PermuteItem<Union, Item>\r\n    } else {\r\n        return never\r\n    }\r\n}\r\n\r\ntype function IsNever = (T) => ^{\r\n    if([T] extends [never]) {\r\n        return true\r\n    } else {\r\n        return false\r\n    }\r\n}\r\n\r\ntype function PermuteItem = (Union, Item, Rest = Exclude<Union, Item>) => ^{\r\n    if(IsNever<Rest> extends true) {\r\n        return [Item]\r\n    } else {\r\n        return [Item, ...Permutation<Rest>]\r\n    }\r\n}\r\n"}