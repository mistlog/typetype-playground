{"code":"/**\r\n * ----------------------------------------\r\n * The Basics\r\n */\r\n\r\n/**\r\n * Import types from another file\r\n */\r\nimport { Temp } from \"./to-import\"\r\n\r\n/**\r\n * Keyword Types\r\n */\r\ntype keywordTypes = [string, number, boolean, never, any, bigint, object]\r\n\r\n/**\r\n * Literal Types\r\n */\r\ntype literals = [\r\n    /**\r\n     * string: use double quote\r\n     */\r\n    \"abc\",\r\n    /**\r\n     * boolean\r\n     */\r\n    true, false,\r\n    /**\r\n     * number\r\n     */\r\n    0, 1, 2,\r\n    /**\r\n     * array\r\n     */\r\n    string[][],\r\n    /**\r\n     * template string\r\n     */\r\n    `name: ${string}`,\r\n    /**\r\n     * object: use \",\" to separate members\r\n     */\r\n    {\r\n        readonly a?: 1,\r\n        b: \"abc\",\r\n        c: {\r\n            a: boolean\r\n        }\r\n    }\r\n]\r\n\r\n/**\r\n * Function Types\r\n */\r\ntype f1 = type () => void\r\ntype f2 = type(a: number, b: string) => number\r\ntype f3 = type () => type(a: number, b: string) => void\r\n\r\n/**\r\n * ----------------------------------------\r\n * Create Type From Type\r\n */\r\n\r\n/**\r\n * Union & Intersection Types\r\n */\r\ntype u1 = union[0, 1, 2]\r\ntype u2 = | [0, 1, 2]\r\n/* add parenthesis for function in union */\r\ntype u3 = union [\r\n    (type () => 1),\r\n    (type () => \"1\")\r\n]\r\n\r\ntype i1 = combine[{ a: 1 }, { b: 2 }]\r\ntype i2 = & [{ a: 1 }, { b: 2 }]\r\n\r\n/**\r\n * Indexed Access Types\r\n */\r\ntype Person = { age: number, name: string, alive: boolean }\r\ntype Age = Person[\"age\"]\r\n\r\n/**\r\n * Keyof Type Operator\r\n */\r\ntype Point = { x: number, y: number }\r\ntype P = keyof Point\r\n\r\n\r\n/**\r\n * Conditional Types\r\n */\r\n\r\n/* type typeofNumber1 = 1 extends string ? \"string\" : \"number\" */\r\ntype typeofNumber1 = ^{\r\n    if(1 extends string) {\r\n        return \"string\"\r\n    } else {\r\n        return \"number\"\r\n    }\r\n}\r\n\r\n/**\r\n * Generic Types\r\n */\r\n\r\n/* export type Foo<T> = T extends { a: infer U; b: infer U; } ? U : never */\r\nexport type function Foo = (T) => ^{\r\n    if(T extends { a: infer U, b: infer U }) {\r\n        return U\r\n    } else {\r\n        return never\r\n    }\r\n}\r\n\r\n/**\r\n * Mapped Types \r\n */\r\ntype Keys = union [\"Name\", \"Age\"]\r\n\r\n\r\n/* type mapped1 = { [K in Keys]: boolean } */\r\ntype mapped1 = ^{\r\n    for(K in Keys) {\r\n        return {\r\n            key: K,\r\n            value: boolean\r\n        }\r\n    }\r\n}\r\n\r\n/* type mapped2 = { [K in Keys as `get${K}`]: () => string } */\r\ntype mapped2 = ^{\r\n    for(K in Keys) {\r\n        return {\r\n            key: `get${K}`,\r\n            value: type() => string\r\n        }\r\n    }\r\n}"}